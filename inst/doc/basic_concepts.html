<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="Author" />

<meta name="date" content="2019-02-10" />

<title>Showcase: Basic Concepts: PipeOp and Graph</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css" data-origin="pandoc">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; position: absolute; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; }
pre.numberSource a.sourceLine:empty
  { position: absolute; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: absolute; left: -5em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' || rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>



<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#header {
text-align: center;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; }  code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>

</head>

<body>




<h1 class="title toc-ignore">Showcase: Basic Concepts: PipeOp and Graph</h1>
<h4 class="author"><em>Author</em></h4>
<h4 class="date"><em>2019-02-10</em></h4>



<p>This tutorial focusses on the more technical concepts underlying <code>mlr3pipelines</code>. The core building blocks of a <code>Pipeline</code> are <strong>PipeOperators</strong> (<code>PipeOp</code>) and <strong>Graphs</strong>.</p>
<div id="pipeop-a-pipeop-is-a-node-that-transforms-data-flowing-through-it." class="section level4">
<h4>PipeOp: A <code>PipeOp</code> is a node, that transforms data flowing through it.</h4>
</div>
<div id="graph-a-graph-is-a-concatenation-of-one-or-several-pipeops." class="section level4">
<h4>Graph: A <code>Graph</code> is a concatenation of one or several <code>PipeOps</code>.</h4>
<p>By connecting several <code>PipeOp</code>s we can build a <code>Graphs</code>. We will use the terms <strong>Pipeline</strong> and <strong>Graph</strong> interchangeably in this section, as a Pipeline inherently is a <strong>Directed Acyclic Graph</strong>. Before diving deeper into the concept of <code>Graph</code>s, we will quickly look into its basic building blocks: <code>PipeOp</code>s.</p>
</div>
<div id="pipeop" class="section level2">
<h2>PipeOp</h2>
<p>In order to construct complicated pipelines, different PipeOps that help organizing how the data flows through the graph are required. We will quickly introduce two examples, where this becomes aparent:</p>
<ul>
<li>We want to execute a part of the <code>Pipeline</code> only if certain criteria are met.</li>
<li>We want to use the same data with different transformations and later on combine those.</li>
</ul>
<p>In <code>mlr3pipelines</code> we consider <span class="math inline">\(3\)</span> basic types of PipeOps; <em>linear</em>, <em>broadcast</em> and <em>aggregate</em>:</p>
<table>
<thead>
<tr class="header">
<th>Type</th>
<th>Input Dim</th>
<th>Output Dim</th>
<th>Examples</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>linear</td>
<td>1</td>
<td>1</td>
<td>PipeOpPCA</td>
</tr>
<tr class="even">
<td>linear</td>
<td>1</td>
<td>1</td>
<td>PipeOpLearner</td>
</tr>
<tr class="odd">
<td>broadcast</td>
<td>1</td>
<td>n</td>
<td>PipeOpCopy</td>
</tr>
<tr class="even">
<td>broadcast</td>
<td>1</td>
<td>n</td>
<td>PipeOpBranch</td>
</tr>
<tr class="odd">
<td>aggregate</td>
<td>n</td>
<td>1</td>
<td>PipeOpFeatureUnion</td>
</tr>
<tr class="even">
<td>aggregate</td>
<td>n</td>
<td>1</td>
<td>PipeOpUnbranch</td>
</tr>
</tbody>
</table>
<p>-<strong>linear</strong> <code>PipeOp</code>s transform its inputs and returns a single output. This can for example be rotating the data usign Principle Component Analysis (PCA) and returning the rotated data.</p>
<p>-<strong>broadcast</strong> <code>PipeOp</code>s do some operation on a single input, and return multiple outputs. We could for example chunk the data into several chunks using <code>PipeOpChunk</code> and send each chunk to a different subsequent node.</p>
<p>-<strong>aggregate</strong> <code>PipeOp</code>s recieve multiple inputs and transform them into a single output. This can for example be concatenating features from different inputs to a single task using <code>PipeOpFeatureUnion</code>.</p>
<div id="a-deeper-dive-into-pipeops" class="section level3">
<h3>A deeper dive into PipeOps</h3>
<p>In order to get a better understanding, we focus on an exemplary <code>PipeOp</code>: As an example we choose <code>PipeOpLearner</code>. First, we create an instance of it by calling the <code>$new()</code> method with a learner from <code>mlr3</code>. A <code>PipeOp</code> is an <a href="https://r6.r-lib.org/"><code>R6</code></a> class.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb1-1" data-line-number="1">  <span class="kw">library</span>(mlr3)</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">  <span class="kw">library</span>(mlr3pipelines)</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">  lrn =<span class="st"> </span>mlr_learners<span class="op">$</span><span class="kw">get</span>(<span class="st">&quot;classif.rpart&quot;</span>)</a>
<a class="sourceLine" id="cb1-4" data-line-number="4">  op =<span class="st"> </span>PipeOpLearner<span class="op">$</span><span class="kw">new</span>(lrn)</a></code></pre></div>
<p>The following slots (and more) are contained in each PipeOp: - <code>train</code>: A function used to train with the PipeOp. - <code>predict</code>: A function used to predict with the PipeOp. - <code>id</code>: Allows us to set or get the id of the PipeOp. - <code>param_set</code>: The set of all exposed parameters of the PipeOp. - <code>values</code>: Current hyperparameter settings. - <code>is_trained</code>: Is the PipeOp already trained?</p>
<p>We can check properties by accessing the respective slots.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb2-1" data-line-number="1">  op<span class="op">$</span>id</a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="co">#&gt; [1] &quot;rpart&quot;</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3">  op<span class="op">$</span>is_trained</a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="co">#&gt; [1] FALSE</span></a></code></pre></div>
<p>The <code>param_set</code> and <code>values</code> are required if a PipeOp contains hyperparameters we want to set. See [paradox::ParamSet] for a quick intro on how <code>ParamSet</code>s work.</p>
<p>The <code>train()</code> and <code>predict()</code> functions define the core functionality of our PipeOp. In many cases, in order to not leak information from the test set into the training set it is imperative to treat train and test data separately. In order to achieve this, we requrie a <code>train</code> function that learns the appropriate transformations from the training set and a <code>test</code> function that applies the transformation on future data.</p>
<p>In the case of <code>PipeOpLearner</code> this means the following: - <code>train()</code> trains a model on its input Task and saves the trained model to an additional slot, <code>.$state</code>. It returns a <code>list(NULL)</code>, as subsequent operators usually do not require any output. - <code>predict()</code> uses the model stored in <code>.$state</code> in order to predict the class of a new input task. It returns a [Prediction] object. This object contains the learner’s predictions.</p>
</div>
</div>
<div id="connecting-pipeops-to-a-graph" class="section level2">
<h2>Connecting PipeOps to a Graph</h2>
<p>We define three different <code>PipeOp</code>s, which will be connected to a Pipeline:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3-1" data-line-number="1">pou =<span class="st"> </span>PipeOpUndersample<span class="op">$</span><span class="kw">new</span>()</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">pop =<span class="st"> </span>PipeOpPCA<span class="op">$</span><span class="kw">new</span>()</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">pos =<span class="st"> </span>PipeOpScale<span class="op">$</span><span class="kw">new</span>()</a></code></pre></div>
<p>Now depending on the order of how we connect those <code>PipeOp</code>s, different results can arise:</p>
<p>There are two basic ways of connecting <code>PipeOp</code>s to a <code>Graph</code>:</p>
<div id="using-the-operator" class="section level3">
<h3>Using the <code>%&gt;&gt;%</code> operator</h3>
<p>In order to connect <code>PipeOp</code>s, we can use the <code>%&gt;&gt;%</code> operator. It is conceptually similar to <code>[mlrCPO](https://github.com/mlr-org/mlrCPO)</code>’s <code>%&gt;&gt;%</code> which in turn stems from the idea of <a href="https://cran.r-project.org/web/packages/magrittr/vignettes/magrittr.html"><code>magrittr</code></a>s <code>%&gt;%</code> command.</p>
<p>The following defines a <code>Graph</code>, that connects the outputs of the left hand side <code>PipeOp</code> to the input of the right hand side.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb4-1" data-line-number="1">gr =<span class="st"> </span>pou <span class="op">%&gt;&gt;%</span><span class="st"> </span>pos</a></code></pre></div>
<p>The object returned by this operator is an <a href="https://r6.r-lib.org/"><code>R6</code></a> class: <code>Graph</code> that contains the <code>PipeOp</code>s and some meta-information, i.e. how the different operators are connected.</p>
<p>If we want to extend the <code>Graph</code> by adding another <code>PipeOp</code>, we can simply append another operator. This connects the output of the last <code>PipeOp</code> in the <code>Graph</code> with the input of the new operator.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb5-1" data-line-number="1">gr =<span class="st"> </span>gr <span class="op">%&gt;&gt;%</span><span class="st"> </span>pop </a></code></pre></div>
<p>The <code>%&gt;&gt;%</code> operator also allows us to connect <code>Graphs</code> with <code>Graphs</code>, by connecting the first output of the lhs <code>Graph</code> with the first input of the rhs <code>Graph</code>.</p>
</div>
<div id="building-the-graph-from-scratch" class="section level3">
<h3>Building the Graph from scratch</h3>
<p>We can define the same <code>Graph</code> by sequentially adding <code>PipeOp</code>s to the <code>Graph</code> and connecting them with an <strong>edge</strong>.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb6-1" data-line-number="1">gr =<span class="st"> </span>Graph<span class="op">$</span><span class="kw">new</span>()</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">gr<span class="op">$</span><span class="kw">add_pipeop</span>(pou)</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">gr<span class="op">$</span><span class="kw">add_pipeop</span>(pos)</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">gr<span class="op">$</span><span class="kw">add_edge</span>(<span class="st">&quot;undersample&quot;</span>, <span class="st">&quot;scale&quot;</span>)</a></code></pre></div>
<p>Analogously to how it is done above, we can again add additional <code>PipeOps</code>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb7-1" data-line-number="1">gr<span class="op">$</span><span class="kw">add_pipeop</span>(pop)</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">gr<span class="op">$</span><span class="kw">add_edge</span>(<span class="st">&quot;scale&quot;</span>, <span class="st">&quot;pca&quot;</span>)</a></code></pre></div>
<p>The latter notation has some pro’s and cons: - This is more verbose, but we also have to type out everything. - It is not easily readable - We can connect arbitrary inputs and outputs of <code>PipeOp</code>s. This allows us to specify very complicated Pipelines.</p>
<p>In order to see how the nodes in the graph are connected, we can simply visualize the graph:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb8-1" data-line-number="1">gr<span class="op">$</span><span class="kw">plot</span>()</a></code></pre></div>
</div>
</div>
<div id="graph" class="section level2">
<h2>Graph</h2>
<p>A <code>Graph</code> allows us to connect several <code>PipeOp</code>s together, and thus let’s us control how and in which order data flows through it. It defines vertices that connect the nodes (<code>PipeOp</code>s) to a <code>Graph</code>. It is a container class for the complete computational graph, i.e. it allows us to go through the <code>Graph</code> and <strong>train</strong> or <strong>predict</strong> on every node.</p>
<p>In the example above, a new <code>Graph</code> was constructed using <code>Graph$new()</code>. Then new <code>PipeOp</code>s are added to the <code>pipeop</code> slot using <code>add_pipeop()</code>. <code>pipeops</code> is a [list of <code>PipeOp</code>s] contained in the <code>Graph</code> named by the <code>PipeOp</code>’s <code>$id</code>. Afterwards we added edges between the <code>PipeOp</code>s to the <code>edges</code> slot using <code>add_edge()</code>. <code>edges</code> is a [<code>data.table</code>] with <code>character</code> columns <code>src_id</code>, <code>src_channel</code>, <code>dst_id</code>, <code>dst_channel</code>. This table contains the connections between the <code>PipeOp</code>s, i.e. which PipeOp is connected to which and to which <code>channel</code>.</p>
<p>The full <code>Graph</code> also has an input and output node, i.e. the inputs and outputs of the first <code>PipeOp</code> and the last <code>PipeOp</code> in our <code>Graph</code> respectively. Those can be accessed using <code>$input</code> and <code>$output</code>. They return a [<code>data.table</code>] with <code>character</code> columns <code>name</code>, <code>train</code>, <code>predict</code>, <code>op.id</code>, <code>channel.name</code>. We can obtain the ids of input and output <code>PipeOp</code>s using <code>lhs</code> and <code>rhs</code>.</p>
<p>Additionally, a <code>Graph</code> collects information from the different <code>PipeOp</code>s it contains.</p>
<p>We can obtain a sorted/unsorted list of the id’s of all <code>PipeOps</code> contained in a <code>Graph</code> using <code>ids()</code>. The collection of all <code>packages</code> required to run the <code>Pipeline</code> can be found in the <code>packages</code> slot.</p>
<p>The <code>param_set</code> collects the <code>param_set</code>s of each <code>PipeOp</code> into a single [<code>ParamSet</code>]. Those contain parameters and parameter constraints for all <code>PipeOp</code>s. The actual parameter values can be set or obtained from <code>$param_set$values</code>. Parameter names, as seen by the <code>Graph</code> have the naming scheme <code>&lt;PipeOp$id&gt;.&lt;PipeOp original parameter name&gt;</code>. Changing <code>$param_set$param_vals</code> also propagates the changes directly to the contained <code>PipeOp</code>s and is an alternative to changing a <code>PipeOp</code>s <code>$param_set$param_vals</code> directly.</p>
<p>In order to compare or check whether a <code>Graph</code> has changed, we can obtain its hash:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="co"># First we compute the hash</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2">gr<span class="op">$</span>hash</a>
<a class="sourceLine" id="cb9-3" data-line-number="3"><span class="co"># Now we set the scale parameter of the PCA operator</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4">gr<span class="op">$</span>param_set<span class="op">$</span>values<span class="op">$</span>pca.scale. =<span class="st"> </span><span class="ot">TRUE</span></a>
<a class="sourceLine" id="cb9-5" data-line-number="5"><span class="co"># Compute hash again to see whether the object changed</span></a>
<a class="sourceLine" id="cb9-6" data-line-number="6">gr<span class="op">$</span>hash</a></code></pre></div>
<div id="training-and-prediction" class="section level3">
<h3>Training and Prediction</h3>
<p>The main components of each <code>PipeOp</code> are its <code>train</code> and <code>predict</code> function. The Graph orchestrates the training and prediction of each <code>PipeOp</code> by sequentially training <code>PipeOp</code>s along the <code>Graph</code>. Training a <code>Graph</code> thus corresponds to training each <code>PipeOp</code>. When all <code>PipeOp</code>s are trained, the <code>Graph</code> can be used for prediction.</p>
<p>We can for example train our graph on the <strong>iris</strong> Task.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb10-1" data-line-number="1">gr<span class="op">$</span><span class="kw">train</span>(mlr_tasks<span class="op">$</span><span class="kw">get</span>(<span class="st">&quot;iris&quot;</span>))</a></code></pre></div>
<p>and transform new data with the trained <code>Pipeline</code>:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb11-1" data-line-number="1">gr<span class="op">$</span><span class="kw">train</span>(mlr_tasks<span class="op">$</span><span class="kw">get</span>(<span class="st">&quot;iris&quot;</span>))</a></code></pre></div>
<p>Whether we store the intermediate results in the <code>PipeOp</code>’s <code>$.result</code> slot can be controlled via <code>keep_results</code> . This is can be done mostly for debugging purposes. Default <code>FALSE</code>.</p>
</div>
</div>
<div id="graph-union-and-replication" class="section level2">
<h2>Graph Union and Replication</h2>
<p>We define two important helper functions, that are usefull for building larger <code>Graph</code>s. PipeOp’s can either be added to a <code>Graph</code> sequentially using <code>%&gt;&gt;%</code> or next to each other, i.e. in parallel. This can be achieved using <code>gunion</code> and <code>greplicate</code>. Putting <code>PipeOp</code>s next to each other is especially usefull in situations, where we either want to do <strong>Branching</strong>, e.g. use tuning in order to select which of the operators to use, or <strong>Copying</strong>, where an input is copied to all following nodes, which can then be evaluated in parallel. The resulting outputs can then for example be collected into a single input using <code>PipeOpFeatureUnion</code>.</p>
<div id="gunion" class="section level3">
<h3><code>gunion</code></h3>
<p>We can use <code>gunion</code> to add a list of <code>PipeOp</code>s or <code>Graph</code>s to a ned <code>Graph</code>. This results in a <code>Graph</code> without any edges between the unioned operators.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb12-1" data-line-number="1">gr =<span class="st"> </span><span class="kw">gunion</span>(<span class="kw">list</span>(pou, pop, pos))</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">gr<span class="op">$</span><span class="kw">plot</span>()</a></code></pre></div>
</div>
<div id="greplicate" class="section level3">
<h3><code>greplicate</code></h3>
<p>A <code>PipeOp</code> or <code>Graph</code> can also be replicated <span class="math inline">\(n\)</span> times using <code>greplicate</code>. In this example, we again use the <code>PipeOp</code>s for Undersampling (pou) and CPA (pop) defined above and connect them to a simple <code>Graph</code>. We can then replicate this <code>Graph</code> <span class="math inline">\(4\)</span> times in order to do Principal Component Analysis <span class="math inline">\(4\)</span> times after obtaining <span class="math inline">\(4\)</span> different subsamples of our input data..</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb13-1" data-line-number="1">gr =<span class="st"> </span>pou <span class="op">%&gt;&gt;%</span><span class="st"> </span>pop</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">gr2 =<span class="st"> </span><span class="kw">greplicate</span>(gr, <span class="dv">4</span>)</a>
<a class="sourceLine" id="cb13-3" data-line-number="3">gr<span class="op">$</span><span class="kw">plot</span>()</a></code></pre></div>
</div>
</div>
<div id="meta-pipeoperators" class="section level2">
<h2>Meta Pipeoperators</h2>
<p>We additionally want to detail some meta operators that can be useful in the process of building pipelines.</p>
<div id="pipeopnull" class="section level3">
<h3>PipeOpNULL</h3>
<p>It is often useful to simply pass on the data unchanged, while the data is transformed by some <code>PipeOp</code> in parallel. This can be done using <code>PipeOpNull</code>, which simply passes on its inputs unchanged, both during the training and the predict phase. An example for this can be seen in the vignette on <strong>Stacking</strong>.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb14-1" data-line-number="1">po_null =<span class="st"> </span>PipeOpNULL<span class="op">$</span><span class="kw">new</span>()</a>
<a class="sourceLine" id="cb14-2" data-line-number="2"><span class="kw">gunion</span>(<span class="kw">list</span>(pop, po_null))</a></code></pre></div>
</div>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
