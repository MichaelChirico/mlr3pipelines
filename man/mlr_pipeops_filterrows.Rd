% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/PipeOpFilterRows.R
\name{mlr_pipeops_filterrows}
\alias{mlr_pipeops_filterrows}
\alias{PipeOpFilterRows}
\title{PipeOpFilterRows}
\format{\code{\link{R6Class}} object inheriting from \code{\link{PipeOp}}.}
\description{
WORK IN PROGRESS (more like a toy example). Filters a task based on row
indices supplied as integer parameters. The number of outputs therefore
directly depends on the number of parameter vectors supplied. Row
indices must be unique and in union be the same as all row indices of the
data of the task. Prediction is not clear, yet.
}
\section{Construction}{
\preformatted{PipeOpFilterRows$new(id = "filterrows", param_vals = list())
}
\itemize{
\item \code{id} :: \code{character(1)}\cr
Identifier of resulting object, default \code{"copy"}.
\item \code{param_vals} :: named \code{list}\cr
List of row indices (integer) that are used for filtering the task.
}
}

\section{Input and Output Channels}{

\code{\link{PipeOpFilterRows}} has one input channel named \code{"input"}, taking a
\code{\link[mlr3:Task]{Task}}, or a subclass of \code{\link[mlr3:Task]{Task}} if the
\code{task_type} construction argument is given as such; both during training and
prediction.

\code{\link{PipeOpFilterRows}} has multiple output channels depending on the length of
the \code{param_vals} list, named \code{"output1"}, \code{"output2"}, ... All output
channels produce the object given as input (\code{"*"}).
}

\section{State}{

The \verb{$state} is left empty (\code{list()}).
}

\section{Parameters}{

\code{\link{PipeOpFilterRows}} takes a list of parameters that should consists of
integer vectors that resemble row indices of the data of the task which are
used to filter the task.
}

\section{Internals}{

Highly experimental.
}

\section{Fields}{

Only fields inherited from \code{\link{PipeOp}}.
}

\section{Methods}{

Only methods inherited from \code{\link{PipeOp}}.
}

\examples{
# Simple binary split
library("mlr3")
task = tsk("iris")
grp1 = which(task$data(cols = "Sepal.Length") < 5.1)
grp2 = setdiff(task$row_ids, grp1)
po1 = mlr_pipeops$get("filterrows", param_vals = list(grp1 = grp1, grp2 = grp2))
po1$train(list(task))
}
\seealso{
Other PipeOps: 
\code{\link{PipeOpEnsemble}},
\code{\link{PipeOpImpute}},
\code{\link{PipeOpTaskPreproc}},
\code{\link{PipeOp}},
\code{\link{mlr_pipeops_boxcox}},
\code{\link{mlr_pipeops_branch}},
\code{\link{mlr_pipeops_chunk}},
\code{\link{mlr_pipeops_classbalancing}},
\code{\link{mlr_pipeops_classifavg}},
\code{\link{mlr_pipeops_classweights}},
\code{\link{mlr_pipeops_colapply}},
\code{\link{mlr_pipeops_collapsefactors}},
\code{\link{mlr_pipeops_copy}},
\code{\link{mlr_pipeops_encodeimpact}},
\code{\link{mlr_pipeops_encodelmer}},
\code{\link{mlr_pipeops_encode}},
\code{\link{mlr_pipeops_featureunion}},
\code{\link{mlr_pipeops_filter}},
\code{\link{mlr_pipeops_fixfactors}},
\code{\link{mlr_pipeops_histbin}},
\code{\link{mlr_pipeops_ica}},
\code{\link{mlr_pipeops_imputehist}},
\code{\link{mlr_pipeops_imputemean}},
\code{\link{mlr_pipeops_imputemedian}},
\code{\link{mlr_pipeops_imputenewlvl}},
\code{\link{mlr_pipeops_imputesample}},
\code{\link{mlr_pipeops_kernelpca}},
\code{\link{mlr_pipeops_learner}},
\code{\link{mlr_pipeops_missind}},
\code{\link{mlr_pipeops_modelmatrix}},
\code{\link{mlr_pipeops_mutate}},
\code{\link{mlr_pipeops_nop}},
\code{\link{mlr_pipeops_pca}},
\code{\link{mlr_pipeops_quantilebin}},
\code{\link{mlr_pipeops_regravg}},
\code{\link{mlr_pipeops_removeconstants}},
\code{\link{mlr_pipeops_scalemaxabs}},
\code{\link{mlr_pipeops_scalerange}},
\code{\link{mlr_pipeops_scale}},
\code{\link{mlr_pipeops_select}},
\code{\link{mlr_pipeops_smote}},
\code{\link{mlr_pipeops_spatialsign}},
\code{\link{mlr_pipeops_subsample}},
\code{\link{mlr_pipeops_unbranch}},
\code{\link{mlr_pipeops_yeojohnson}},
\code{\link{mlr_pipeops}}

Other Placeholder Pipeops: 
\code{\link{mlr_pipeops_copy}},
\code{\link{mlr_pipeops_nop}}
}
\concept{PipeOps}
\concept{Placeholder Pipeops}
